// Basic on/off switches
FF-new-ui -> true
FF-beta-features -> false
FF-maintenance-mode -> false

// Configuration values
FF-api-timeout -> 5000
FF-max-retries -> 3
FF-log-level -> "debug"

// Feature variants
FF-button-color -> "blue"
FF-theme-config -> json({
  "primaryColor": "#007bff",
  "secondaryColor": "#6c757d",
  "darkMode": true,
  "animations": true
})

// once you dont have rules you can use short notation to return boolean
FF-feature-flat-on-off -> true

// you can return non-boolean in this example json. or empty json object json({})
FF-feature-json-variant -> json({"success": true})

// features are forced to start with FF- case-sensitive as
// it allows you later to find all flags through in codebase
FF-feature-name-specifics -> false

// can be snake_case as well as kebab-case
FF_feature_can_be_snake_case_213213 -> FALSE

// can be camelCase
FF_featureOneOrTwo -> FALSE

// can be PascalCase
FF_Feature23432 -> TRUE

// you can have feature with multiple rules in it with default flag value returned in end
// we can have test of feature embeded together with feature flag which can be ran with `ff test`
// @test FF-feature-y(countryCode=nl) == true
FF-feature-y {
    // if country is NL return True
    lower(countryCode) == nl -> true
    // else default to false
    false
}

// you can also return different variations (non-boolean) as example json
FF-testing {
    // default variant
    json({"success": true})
}

@segment complex_segment_test {
    a = b and c=d and (dd not in (1,2,3) or z == "demo car")
}

// and have more complex feature with multiple rules in it, which at the end defaults to false
// @test FF-feature-complex-ticket-234234(a=b, c=d, dd=4, z="demo car") == true
FF-feature-complex-ticket-234234 {
    // complex bool expression
    segment(complex_segment_test) -> TRUE

    // another one
    z == "demo car" -> FALSE

    // with checking more
    g in (4,5,6) and z == "demo car" -> json({"success": true})

    // and multi-line rule works
    model in (ms,mx,m3,my) and created >= 2024-01-01
        and demo == false -> TRUE

    FALSE
}

// Semver version checks
@expires 2027-01-01
@owner "Nikolajus"
@test FF-sdk-upgrade(appVersion=5.4) == true
FF-sdk-upgrade {
    @env stage {
        appVersion >= 5.3.42 -> false
        appVersion < 4.32.0 -> false
        false
    }
    @env dev -> true

    // enable new SDK for apps on version 5.3.42 or higher
    appVersion >= 5.3.42 -> true
    // disable for apps below 4.32.0
    appVersion < 4.32.0 -> false
    // default: keep old SDK
    false
}

// different kind of comments inside
FF-feature1 {
    /* comment like this */
    true
    a == "something" -> false
    false
    json({})
}

// @author Nikolajus K
// @expires 2024-12-31 00:00:00
FF-flag-with-annotations -> true

/**
 * @author Nikolajus K
 * @expires 2024-12-31 00:00:00
 *
 * test can be also in block comments
 * @test FF-flag-with-annotations-2 == false
 */
FF-flag-with-annotations-2 -> false

/**
 multiline comments
 or test can be in multiline comments
 @test FF-timer-feature() == true
 */
FF-timer-feature {
    // turn on only on evaluation time after 22nd feb
    NOW() > 2026-02-07 -> true
    false
}

// check if name contains Nik
// @test FF-contains-feature-check(name="Nikolajus") == true
@test FF-contains-feature-check(name="Nikola") == true
FF-contains-feature-check {
    lower(name) ~ nik -> true // contains
    name !~ Nik -> false // does not contain
    false
}

// check if email ends with a specific domain
// @test FF-email-domain-check(email="user@company.com") == true
// @test FF-email-domain-check(email="user@other.com") == false
FF-email-domain-check {
    email ~$ "@company.com" -> true
    false
}

// check if path starts with /admin
// @test FF-admin-path-check(path="/admin/settings") == true
// @test FF-admin-path-check(path="/user/profile") == false
FF-admin-path-check {
    path ^~ "/admin" -> true
    false
}

// Gradual rollout with percentage-based bucketing
// @test FF-new-checkout(userId=20) == true
FF-new-checkout {
    percentage(50%, userId) -> true
    false
}

// @test FF-gradual-migration(orgId=3, plan=premium) == true
FF-gradual-migration {
    percentage(50%, orgId) and plan == "premium" -> true
    percentage(10%, orgId) -> true
    false
}

// check name against regexp /.*ola.*/
// @test FF-regexp-feature-check(name="Check Nikolajus match") == true
FF-regexp-feature-check {
    UPPER(name) ~ /.*OLA.*/ -> true // matches regex
    name !~ /.*ola.*/ -> false // does not match regexp
    false
}

@type experiment
@test FF-launch-event == true
FF-launch-event {
    now() > 2025-06-15T09:00:00Z and now() < 2027-01-15T18:00:00Z -> true
    false
}

@test FF-debug-env-logging == false
FF-debug-env-logging {
    @env dev->true
    @env stage->true
    @env prod->false
    false
}

/**
  flag dependency feature check
  */
FF-dep-root-new-checkout->true

// This flag only evaluates if FF-dep-root-new-checkout is true
@requires FF-dep-root-new-checkout
@test FF-checkout-upsell(userId=20) == true
FF-checkout-upsell {
    userId in (20, 21, 22) -> true
    false
}

// checking coalesce fn
@ticket "JIRA-1234"
@description "GEO feature based on country or region"
@test FF-geo-features(region=NL) == true
@test FF-geo-features(countryCode=NL) == true
@test FF-geo-features() == false
FF-geo-features {
    // Use countryCode if present, fall back to region, then "unknown"
    coalesce(countryCode, region, "unknown") == "NL" -> true
    false
}

// reverse array
@test FF-admin-panel(roles=["viewer", "editor", "admin"]) == true
FF-admin-panel {
    // roles is an array: ["viewer", "editor", "admin"]
    "admin" in roles -> true
    false
}

@deprecated "Use FF-new-checkout instead"
@expires 2027-01-01
FF-old-checkout -> true

// is null & is not null
@test FF-null-check-flag-demo(plan=premium) == false
@test FF-null-check-flag-demo(userId=20, plan=premium) == true
FF-null-check-flag-demo {
    userId is null -> false
    userId is not null and plan == premium -> true
    false
}